<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuzh0507.github.io</id>
    <title>Station of Alvin</title>
    <updated>2022-05-20T14:34:10.265Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuzh0507.github.io"/>
    <link rel="self" href="https://yuzh0507.github.io/atom.xml"/>
    <subtitle>Record every step of my way</subtitle>
    <logo>https://yuzh0507.github.io/images/avatar.png</logo>
    <icon>https://yuzh0507.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Station of Alvin</rights>
    <entry>
        <title type="html"><![CDATA[Data Structure and Algorithm in C++]]></title>
        <id>https://yuzh0507.github.io/post/data-structure-and-algorithm-in-c/</id>
        <link href="https://yuzh0507.github.io/post/data-structure-and-algorithm-in-c/">
        </link>
        <updated>2022-05-19T02:26:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="data-structure">Data Structure</h1>
<h2 id="1-introduction">1. Introduction</h2>
<p>Main memory is divided into 3 sections: Code Section, Stack, Heap</p>
<ul>
<li>
<p><strong>Static Memory Allocation</strong></p>
<p>How many bytes of memory are required by a certain function was decided at compile time.</p>
</li>
<li>
<p><strong>Stack</strong></p>
<p>After the function is completely executed, the memory will be deleted. The sequence of allocating memory depends on the sequence of executing functions, and the sequence of deleting memory is contrary. So this area is a <strong>stack</strong> (First In Last Out).</p>
</li>
<li>
<p><strong>Heap</strong></p>
<p><strong>Heap</strong> is used for unorganized memory. It shall be treated as a resource. Programs cannot directly access the heap memory, which can only be accessed by a pointer.</p>
</li>
<li>
<p><strong>Physical Data Structure</strong></p>
<p>Structures define how the memory shall be organized for storing the elements or data. (e.g. array, linked list)</p>
</li>
<li>
<p><strong>Logical Data Structure</strong></p>
<p>Structures are implemented using any Physical Data Structure.<br>
Linear: stack(FILO), queue(FIFO)<br>
Non-linear: tree, graph<br>
Tablet: Hashtable</p>
</li>
<li>
<p><strong>Abstract DataType</strong></p>
<p>ADT defines data and operations on data together, and lets it be used as a DataType by hiding all the internal details.</p>
</li>
<li>
<p><strong>Time Complexity</strong></p>
<ul>
<li>
<p>O(n) (pronounciate as “order n”)</p>
<p>For input that has n elements, the program needs n steps to complete the execution.</p>
</li>
<li>
<p>Ignore coefficient</p>
<p>When calculating the time complexity, all the coefficients shall be ignored. E.g., for 2n and n are both seen as O(n)</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Complexity Expression</th>
</tr>
</thead>
<tbody>
<tr>
<td>constant</td>
<td>O(1)</td>
</tr>
<tr>
<td>Linear</td>
<td>O(n)</td>
</tr>
<tr>
<td>Logarithmic</td>
<td>O(log n)</td>
</tr>
<tr>
<td>Quadratic</td>
<td>O(n<sup>2</sup>)</td>
</tr>
<tr>
<td>Exponential</td>
<td>O(2<sup>n</sup>)</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h2 id="2-recursion">2. Recursion</h2>
<p>A function is calling itself is called recursion. Inside the function, there must be some condition which will make the recursion stop.</p>
<pre><code class="language-c++">void fun1(int n)
{
	if(n&gt;0)
	{
		cout &lt;&lt; n &lt;&lt; ' '; // Calling time
		fun1(n-1);
	}
}
// Input: 3
// Output: 3 2 1

void fun2(int n)
{
	if(n&gt;0)
	{		
		fun2(n-1);
		cout &lt;&lt; n &lt;&lt; ' '; // Returning time
	}
}
// Input: 3
// Output: 1 2 3
</code></pre>
<ul>
<li>
<p><strong>Static Variables</strong></p>
<p>Static variables will be treated as a global variable.</p>
<pre><code class="language-c++">// int x = 0; //The same as define a static variable within the function
void fun(int n)
{
	static int x = 0;
	if(n&gt;0)
	{
		x++;
		return fun(n-1) + x;
	}
	return 0;
}
// Input: 5
// Output: 25
</code></pre>
</li>
<li>
<p><strong>Type of Recursion</strong></p>
<ul>
<li>
<p>Tail Recursion</p>
<p>The recursive call is the last statement in a function</p>
<pre><code class="language-c++">// Tail Recursion
void fun1(int n)
{
	if(n&gt;0)
	{
		cout &lt;&lt; n &lt;&lt; ' ';
		fun1(n-1);

}
// Time Complexity: O(n)
// Space Complexity: O(n)
// Everytime the fun1 is called, a new area of memory needs to be built. 

// For loop
void fun2(int n)
{
	while (n &gt; 0)
	{
		cout &lt;&lt; n &lt;&lt; ' ';
		n--;
	}
}
// Time Complexity: O(n)
// Space Complexity: O(1)
</code></pre>
<p>For tail recursion, loop is more efficient in terms of space.</p>
</li>
<li>
<p>Head Recursion</p>
<p>The recursive call is the first statement in a function</p>
<pre><code class="language-c++">// Head Recursion
void fun1(int n)
{
	if(n&gt;0)
	{		
		fun1(n-1);
		cout &lt;&lt; n &lt;&lt; ' ';
	}
}
// Time Complexity: O(n)
// Space Complexity: O(n)
// Everytime the fun1 is called, a new area of memory needs to be built. 

// For loop
void fun2(int n)
{
	int i = 1;
	while (i &lt;= n)
	{
		cout &lt;&lt; i &lt;&lt; ' ';
		i++;
	}
}
// Time Complexity: O(n)
// Space Complexity: O(1)
</code></pre>
<p>For head recursion, loop is more efficient in terms of space.</p>
</li>
<li>
<p>Tree Recursion</p>
<p>If the function is calling itself just once, it’s a Linear Recursion. (Head &amp; Trail Recursion are special ones)</p>
<p>If the function is calling itself more than once, it’s a Tree Recursion.</p>
<pre><code class="language-c++">// Head Recursion
void fun1(int n)
{
	if(n&gt;0)
	{
		cout &lt;&lt; n &lt;&lt; ' ';
		fun1(n-1);
		fun1(n-1);
	}
	return 0;
}
// Time Complexity: O(2^n)
// Space Complexity: O(n)
// Everytime the fun1 is called, a new area of memory needs to be built. 
</code></pre>
</li>
<li>
<p>Indirect Recursion</p>
<p>There are more than one functions, one of them is calling one another.</p>
<pre><code class="language-c++">void fun1(int n)
{
	if(n&gt;0)
	{
		cout &lt;&lt; n &lt;&lt; ' ';
		fun2(n-1);
	}
}

void fun2(int n)
{
	if(n&gt;1)
	{
		cout &lt;&lt; n &lt;&lt; ' ';
		fun1(n/2);
	}
}
// Input for fun1: 20
// Output: 20 19 9 8 4 3 1
</code></pre>
</li>
<li>
<p>Nested Recursion</p>
<p>Recursion inside recursion.</p>
<pre><code class="language-c++">void fun(int n)
{
	if(n&gt;100)
	{
		return n-10;
	}
	else
	{
		return fun(fun(n+11));
	}
}
// Input: 95
// Output: 91
// fun(95) = fun(fun(106)) = fun(96) = fun(97) = ... = fun(fun111)) = fun(101) = 91
</code></pre>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode Record]]></title>
        <id>https://yuzh0507.github.io/post/leetcode-record/</id>
        <link href="https://yuzh0507.github.io/post/leetcode-record/">
        </link>
        <updated>2022-05-04T00:51:04.000Z</updated>
        <content type="html"><![CDATA[<p>In order to learn C++ programming skills, I decide to start to do exercises on <a href="https://leetcode.com/">LeetCode</a>.</p>
<h1 id="easy-problems">Easy Problems</h1>
<p><a href="https://yuzh0507.github.io/post/1-two-sum">1. Two Sum</a><br>
<a href="https://yuzh0507.github.io/post/9-palindrome-number">9. Palindrome Number</a><br>
<a href="https://yuzh0507.github.io/post/13-roman-to-integer">13. Roman to Integer</a><br>
<a href="https://yuzh0507.github.io/post/26-remove-duplicates-from-sorted-array">26. Remove Duplicates from Sorted Array</a></p>
<h1 id="medium-problems">Medium Problems</h1>
<p><a href="https://yuzh0507.github.io/post/2-add-two-numbers">2. Add Two Numbers</a><br>
<a href="https://yuzh0507.github.io/post/3-longest-substring-without-repeating-characters">3. Longest Substring Without Repeating Characters</a><br>
<a href="https://yuzh0507.github.io/post/5-longest-palindromic-substring">5. Longest Palindromic Number</a><br>
<a href="https://yuzh0507.github.io/post/6-zigzag-conversion">6. Zigzag Conversion</a><br>
<a href="https://yuzh0507.github.io/post/7-reverse-integer">7. Reverse Integer</a><br>
<a href="https://yuzh0507.github.io/post/8-string-to-integer-atoi">8. String to Integer (atoi)</a><br>
<a href="https://yuzh0507.github.io/post/11-container-with-most-water">11. Container With Most Water</a><br>
<a href="https://yuzh0507.github.io/post/12-integer-to-roman">12. Integer to Roman</a><br>
<a href="https://yuzh0507.github.io/post/15-3sum">15. 3Sum</a><br>
<a href="https://yuzh0507.github.io/post/16-3sum-closest">16. 3Sum Closest</a><br>
<a href="https://yuzh0507.github.io/post/17-letter-combinations-of-a-phone-number">17. Letter Combinations of a Phone Number</a><br>
<a href="https://yuzh0507.github.io/post/18-4sum">18. 4Sum</a><br>
<a href="https://yuzh0507.github.io/post/19-remove-nth-node-from-end-of-list">19. Remove Nth Node From End of List</a><br>
<a href="https://yuzh0507.github.io/post/24-swap-nodes-in-pairs">24. Swap Nodes in Pairs</a><br>
<a href="https://yuzh0507.github.io/post/31-next-permutation">31. Next Permutation</a><br>
<a href="https://yuzh0507.github.io/post/33-search-in-rotated-sorted-array">33. Search in Rotated Sorted Array</a></p>
<h1 id="hard-problems">Hard Problems</h1>
<p><a href="https://yuzh0507.github.io/post/10-regular-expression-matching">10. Regular Expression Matching</a><br>
<a href="https://yuzh0507.github.io/post/23-merge-k-sorted-lists">23. Merge k Sorted Lists</a><br>
<a href="https://yuzh0507.github.io/post/25-reverse-nodes-in-k-group">25. Reverse Nodes in k-Group</a><br>
<a href="https://yuzh0507.github.io/post/30-substring-with-concatenation-of-all-words">30. Substring with Concatenation of All Words</a><br>
<a href="https://yuzh0507.github.io/post/32-longest-valid-parentheses">32. Longest Valid Parentheses</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UDP Summary]]></title>
        <id>https://yuzh0507.github.io/post/udp-summary/</id>
        <link href="https://yuzh0507.github.io/post/udp-summary/">
        </link>
        <updated>2019-11-04T10:52:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-summary">1 Summary</h1>
<p>UDP(User Datagram Protocol) is a regular and simple protocol of the transport layer. It offers service of transmitting messages between applications.</p>
<h1 id="2-format">2 Format</h1>
<h2 id="21-udp-header">2.1 UDP Header</h2>
<figure data-type="image" tabindex="1"><img src="https://yuzh0507.github.io/post-images/1572865440084.PNG" alt="" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>Field</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>Source Port</td>
<td>The transport port of sending process</td>
</tr>
<tr>
<td>Destination Port</td>
<td>The transport port of the destination of the message</td>
</tr>
<tr>
<td>Length</td>
<td>Length in octets of of this datagram including header and data</td>
</tr>
<tr>
<td>checksum</td>
<td>The 16-bit one’s complement of the one’s complement sum of a pseudo header</td>
</tr>
</tbody>
</table>
<h2 id="22-pseudo-header">2.2 Pseudo Header</h2>
<figure data-type="image" tabindex="2"><img src="https://yuzh0507.github.io/post-images/1572865765825.PNG" alt="" loading="lazy"></figure>
<p>The pseudo header includes IP address in addition to UDP information. The specific implementation will be discussed in next update.</p>
<h1 id="3-user-interface">3 User Interface</h1>
<p>A user interface should allow:</p>
<ul>
<li>The creation of new receive ports,</li>
<li>receive operations on the receive ports that return the data octets and an indication of source port and source address,</li>
<li>an operation that allows a datagram to be sent, specifying the data, source and destination ports and addresses to be sent.</li>
</ul>
<h1 id="4-ip-interface">4 IP Interface</h1>
<p>The UDP module must be able to determine the source and destination internet addresses and the protocol field from the internet header. One possible UDP/IP interface would return the whole internet datagram including all of the internet header in response to a receive operation. Such an interface would also allow the UDP to pass a full internet datagram complete with header to the IP to send. The IP would verify certain fields for consistency and compute the internet header checksum.</p>
<h1 id="5-ports">5 Ports</h1>
<p>The UDP well-known ports is identical to TCP well-known ports. Some frequently used ports are showned as below.</p>
<table>
<thead>
<tr>
<th>Port Number</th>
<th>Application Protocol</th>
</tr>
</thead>
<tbody>
<tr>
<td>53</td>
<td>DNS</td>
</tr>
<tr>
<td>67, 68</td>
<td>DHCP</td>
</tr>
</tbody>
</table>
<h1 id="6-implementation-in-automotive-ethernet">6 Implementation in Automotive Ethernet</h1>
<h2 id="61-application-scenarios">6.1 Application Scenarios</h2>
<p>Most messages within the automotive Environment are considerably important which need reliable service provided by the transport layer. Since the UDP is good at speed but not reliable, the utilization shall be deliberated by designers.</p>
<h2 id="62-length">6.2 Length</h2>
<p>Since the MTU of automotive Ethernet is constantly 1500 Bytes, designers may forbid the fragmenation of IP. In this case, The length of UDP messages shall be limited to fulfill the limitation of MTU.</p>
]]></content>
    </entry>
</feed>